require 'rattler'
require_relative './parser_parts/variable_binding'
require_relative './parser_parts/unbounded_size'
require_relative './parser_parts/const_size'
require_relative './parser_parts/reference_size'
require_relative './parser_parts/bits'
require_relative './parser_parts/bytes'
require_relative './parser_parts/rule_reference'
require_relative './parser_parts/byte_body'
require_relative './parser_parts/components'
require_relative './parser_parts/rule_body'
require_relative './parser_parts/disjunction'
require_relative './parser_parts/conjunction'
require_relative './parser_parts/repeat'
require_relative './parser_parts/rule'
require_relative './parser_parts/size'
require_relative './parser_parts/eof'
require_relative './parser_parts/sum'
require_relative './parser_parts/sub'
require_relative './parser_parts/div'
require_relative './parser_parts/mul'

parser PogglerParser < Rattler::Runtime::PackratParser

%whitespace BLANK*

start   <- ext? functions? components  { Components.new _.last[0], _.last[1] }

functions <- ~':functions:' ~newln function (~newln+ function)* ~newln ~newln

function <- name ~'(' size_t ~'):' (size_t / name) ~{
  puts "Read function declaration " + _[0]
  _
}

components <- ~':components:' ~newln rule (~newln+ rule)* ~newln
rule <- name definition                       {
  Rule.new _[0], _[1]
}

name <- @(WORD+)

definition <-
  size body { RuleBody.new _[0], _[1] } /
  body { RuleBody.new nil, _ } /
  size { RuleBody.new _, nil }

body <- ~':=' rule_expr                      ~{
  puts("  body: " + _.to_s)
  _
}

rule_expr <- rule_body
rule_body <- rule_cons
rule_cons <-
  rule_opt ~":" rule_cons  { Conjunction.new _[0], _[1] } /
  rule_opt
rule_opt <-
  rule_statement ~'|' rule_opt  { Disjunction.new _[0], _[1] } /
  rule_statement
rule_statement <-
  rule_with_variable_binding /
  function_with_args /
  rule_atom size_multiple?  {
    if _[1] != []
      Repeat.new _[1][0], _[0]
    else
      _[0]
    end
  }
function_with_args <- name '(' name (',' name)* ')' ~{
  puts "Function call of " + _[0] + " with " + _[1] + " and others?"
  _
}
rule_with_variable_binding <- name ~"\\" rule_atom   {
  puts "Rule binding: " + _[0] + " is result of " + _[1].to_s
  VariableBinding.new _[0], _[1]
}
rule_atom <-
  'eof'     { Eof.new } /
  lit_byte  { ByteBody.new _ } /
  name      { RuleReference.new _ } /
  ~'(' rule_expr ~')'

size <- ~':' size_t                          ~{
  puts _
  _
}
size_t <-
  ~'bit' size_multiple? {
    Bits.new _[0]
  } /
  ~'byte' size_multiple? {
    Bytes.new _[0]
  }
size_multiple <- ~'{' size_expr ~'}' {
  Size.new _
}
size_expr <- size_mult
size_mult <-
  size_atom ~'/' size_mult { Div.new _[0], _[1] } /
  size_atom ~'*' size_mult { Mul.new _[0], _[1] } /
  size_sum
size_sum <-
  size_atom ~'-' size_sum { Sub.new _[0], _[1] } /
  size_atom ~'+' size_sum { Sum.new _[0], _[1] } /
  size_atom
size_atom <- size_const / size_unknown / size_label / ~'(' size_expr ~')'
size_unknown <- '_' {
  UnboundedSize.new _
}
size_const <- @(DIGIT+) {
  ConstSize.new _
}
size_label <- name { 
  ReferenceSize.new _, Components.vars
}

ext <- ~':ext:' ~newln exts ~newln ~newln    ~{
  puts("Expected extensions: " + _.join(', '))
  _
}
exts <- ~'[' ext_str (~',' ext_str)* ~']'
ext_str <- @('"' '.' ALNUM* '"')

lit_byte <- @('0x' XDIGIT XDIGIT)
newln <- "\n"

